<div class="row">
	<div class="col-3">
		{{inner-navigation}}	
	</div>
	<div class="col-9">

<p class="text-indent">
	<b>Немного истории.</b>
</p>
<p class="text-indent">
	Началось всё лет 6 назад, когда я (как и многие программисты) увлёкся идеей создания своего Искусственного Интеллекта.
</p>
<p class="text-indent">
	Я начал с того что стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.
</p>
<p class="text-indent">
	Я выбрал в качестве основы сети семантические сети и стал экспериментировать. В начале просто создавать граф каких-то знаний. Узел представлял собой описание и список связей со многими другими узлами. При этом одновременно он являлся сам связью. Мне казалось это даст огромную гибкость. Но в итоге я начал путаться в том что творил. После нескольких итераций я оставил в узле три связи - источник, приёмник и тип связи. На этой основе я даже накидал некоторую вроде как базу знаний, которой можно было сообщать факты и которая сама задавала вопросы. Вопросы создавались рандомно и были довольно сумасшедшими: "Является ли Красный Ветром?".
</p>
<p class="text-indent">
	В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) я окончательно осознал, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.
</p>
<p class="text-indent">
	Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.
</p>

<br>
<hr>
<br>

<p class="text-indent">
	<b>Язык Bombardo.</b>
</p>
<p class="text-indent">
	Как и в обычном Lisp программа состоит из атомов.
</p>
<p class="text-indent">
	Существуют следующие атомы:
	<ul>
		<li>Точечная пара</li>
		<li>Символ</li>
		<li>Число</li>
		<li>Строка</li>
		<li>Флаг (Булево значение) (true | false)</li>
		<li>Функция</li>
		<li>Нативный объект (ссылается на любой объект C#)</li>
	</ul>
</p>

<p class="text-indent">
	Точечная пара:
	<pre><code>
	( symbolA . symbolB )
	</code></pre>
	Цепочка пар является списком. Эти две записи эквивалентны:
	<pre><code>
	( a . ( b . ( c . null )))
	( a b c )
	</code></pre>
</p>
<p class="text-indent">
	Язык поддерживает два типа скобок: круглые и квадратные.
	Скобки равнозначны между собой, но нельзя сочетать разные скобки^
	<pre><code>
		;   Корректно
		( exp )
		[ exp ]
		;   Некорректно
		( exp ]
		[ exp )
	</code></pre>
</p>

<p class="text-indent">
	Интерпретатор исполняет программу в некотором контексте, который хранит значения символов.
Контекст является таблицей, в которой символ является ключом, а значение - любой атом или список.
</p>
<p class="text-indent">
</p>
<p class="text-indent">
</p>
<p class="text-indent">
</p>
<p class="text-indent">
</p>




Исполнение программы производится сходным с лисплм образом.
<pre><code>
( procedureName argument1 argument2 ... )
</code></pre>
Сначала интерпретатор исполняет голову списка procedureName.
Если в результате исполнения получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
 - вычисляются ли их аргументы перед вызовом
 - вычисляются ли возвращаемое значение
Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:
 - Числовые, Строковые и Булевы атомы остаются без изменений
 - Атомы с нативными объектами остаются без изменений
 - Атомы с функциями остаются без изменений
 - Символы интерпретируются как ключи, по которым производится поиск в текущем и родительском контексте. Если значения найти не удалось - исполнение прерывается.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора.

Функция объявляется выражением:
<pre><code>
(lambda (arguments) body )
</code></pre>

Макрос:
<pre><code>
(macros (arguments) body )
</code></pre>

Кроме того есть форма с явным определением флагов исполнения:
<pre><code>
(syntax (arg res) (arguments) body )
</code></pre>
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
<pre><code>
(lambda (arguments) body ) <--> (syntax (true false) (arguments) body )

(macros (arguments) body ) <--> (syntax (false true) (arguments) body )
</code></pre>




	</div>
</div>



