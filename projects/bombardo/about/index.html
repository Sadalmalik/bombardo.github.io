<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<link rel="stylesheet" href="/css/bootstrap.min.css">
	<link rel="stylesheet" href="/css/custom.css">
	<title>Bombardo project</title>
</head>
<body>
	
	<nav class="navbar navbar-expand-sm navbar-dark bg-dark sticky-top">
		<div class="container">
			<ul class="navbar-nav">
				<li class="nav-item">
	<a class="navbar-brand" href="/projects/bombardo"><b>(</b> Bombardo</a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/about/"><b>(</b> About <b>)</b></a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/overview/"><b>(</b> Overview <b>)</b></a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/documentation/"><b>(</b> Documentation <b>)</b></a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/contacts/"><b>(</b> Contacts <b>)</b></a>
</li>
<li class="nav-item">
	<a class="navbar-brand" href="/projects/bombardo"><b>)</b></a>
</li>

			</ul>
		</nav>
	</nav>
	
	<section class="container text-justify">
	
		<div class="row">
				
<p class="text-indent">
	<b>Немного истории.</b>
</p>
<p class="text-indent">
	Началось всё лет 6 назад, когда я (как и многие программисты) увлёкся идеей создания своего Искусственного Интеллекта.
</p>
<p class="text-indent">
	Я начал с того что стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.
</p>
<p class="text-indent">
	Я выбрал в качестве основы сети семантические сети и стал экспериментировать. В начале просто создавать граф каких-то знаний. Узел представлял собой описание и список связей со многими другими узлами. При этом одновременно он являлся сам связью. Мне казалось это даст огромную гибкость. Но в итоге я начал путаться в том что творил. После нескольких итераций я оставил в узле три связи - источник, приёмник и тип связи. На этой основе я даже накидал некоторую вроде как базу знаний, которой можно было сообщать факты и которая сама задавала вопросы. Вопросы создавались рандомно и были довольно сумасшедшими: "Является ли Красный Ветром?".
</p>
<p class="text-indent">
	В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) я окончательно осознал, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.
</p>
<p class="text-indent">
	Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.
</p>

<br>
<hr>
<br>

<p class="text-indent">
	<b>Язык Bombardo.</b>
</p>
<p class="text-indent">
	Как и в обычном Lisp программа состоит из атомов.
</p>
<p class="text-indent">
	Существуют следующие атомы:
	<ul>
		<li>Точечная пара</li>
		<li>Символ</li>
		<li>Число</li>
		<li>Строка</li>
		<li>Флаг (Булево значение) (true | false)</li>
		<li>Функция</li>
		<li>Нативный объект (ссылается на любой объект C#)</li>
	</ul>
</p>

<p class="text-indent">
	Точечная пара:
	<pre><code>
	( symbolA . symbolB )
	</code></pre>
	Цепочка пар является списком. Эти две записи эквивалентны:
	<pre><code>
	( a . ( b . ( c . null )))
	( a b c )
	</code></pre>
</p>
<p class="text-indent">
	Язык поддерживает два типа скобок: круглые и квадратные.
	Скобки равнозначны между собой, но нельзя сочетать разные скобки^
	<pre><code>
		;   Корректно
		( exp )
		[ exp ]
		;   Некорректно
		( exp ]
		[ exp )
	</code></pre>
</p>

<p class="text-indent">
	Интерпретатор исполняет программу в некотором контексте, который хранит значения символов.
Контекст является таблицей, в которой символ является ключом, а значение - любой атом или список.
</p>
<p class="text-indent">
</p>
<p class="text-indent">
</p>
<p class="text-indent">
</p>
<p class="text-indent">
</p>




Исполнение программы производится сходным с лисплм образом.
<pre><code>
( procedureName argument1 argument2 ... )
</code></pre>
Сначала интерпретатор исполняет голову списка procedureName.
Если в результате исполнения получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
 - вычисляются ли их аргументы перед вызовом
 - вычисляются ли возвращаемое значение
Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:
 - Числовые, Строковые и Булевы атомы остаются без изменений
 - Атомы с нативными объектами остаются без изменений
 - Атомы с функциями остаются без изменений
 - Символы интерпретируются как ключи, по которым производится поиск в текущем и родительском контексте. Если значения найти не удалось - исполнение прерывается.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора.

Функция объявляется выражением:
<pre><code>
(lambda (arguments) body )
</code></pre>

Макрос:
<pre><code>
(macros (arguments) body )
</code></pre>

Кроме того есть форма с явным определением флагов исполнения:
<pre><code>
(syntax (arg res) (arguments) body )
</code></pre>
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
<pre><code>
(lambda (arguments) body ) <--> (syntax (true false) (arguments) body )

(macros (arguments) body ) <--> (syntax (false true) (arguments) body )
</code></pre>








		</div>
		
	</section>
	
	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
	
</body>
</html>