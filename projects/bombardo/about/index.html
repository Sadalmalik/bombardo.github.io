<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<link rel="stylesheet" href="/css/bootstrap.min.css">
	<link rel="stylesheet" href="/css/custom.css">
	<title>Bombardo project</title>
</head>
<body>
	
	<nav class="navbar navbar-expand-sm navbar-dark bg-dark sticky-top">
		<div class="container">
			<ul class="navbar-nav">
				<li class="nav-item">
	<a class="navbar-brand" href="/projects/bombardo"><b>(</b> Bombardo</a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/about/"><b>(</b> About <b>)</b></a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/overview/"><b>(</b> Overview <b>)</b></a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/documentation/"><b>(</b> Documentation <b>)</b></a>
</li>
<li class="nav-item">
	<a class="nav-link" href="/projects/bombardo/contacts/"><b>(</b> Contacts <b>)</b></a>
</li>
<li class="nav-item">
	<a class="navbar-brand" href="/projects/bombardo"><b>)</b></a>
</li>

			</ul>
		</nav>
	</nav>
	
	<section class="container text-justify">
	
		<div class="row">
				<div class="row">
	<div class="col-3">
		{{inner-navigation}}	
	</div>
	<div class="col-9">

<p class="text-indent">
	<b>Немного истории.</b>
</p>
<p class="text-indent">
	Началось всё лет 6 назад, когда я (как и многие программисты) увлёкся идеей создания своего Искусственного Интеллекта.
</p>
<p class="text-indent">
	Я начал с того что стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.
</p>
<p class="text-indent">
	Я выбрал в качестве основы сети семантические сети и стал экспериментировать. В начале просто создавать граф каких-то знаний. Узел представлял собой описание и список связей со многими другими узлами. При этом одновременно он являлся сам связью. Мне казалось это даст огромную гибкость. Но в итоге я начал путаться в том что творил. После нескольких итераций я оставил в узле три связи - источник, приёмник и тип связи. На этой основе я даже накидал некоторую вроде как базу знаний, которой можно было сообщать факты и которая сама задавала вопросы. Вопросы создавались рандомно и были довольно сумасшедшими: "Является ли Красный Ветром?".
</p>
<p class="text-indent">
	В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) я окончательно осознал, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.
</p>
<p class="text-indent">
	Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.
</p>

<br>
<hr>
<br>

<p class="text-indent">
	<b>Язык Bombardo.</b>
</p>
<p class="text-indent">
	Как и в обычном Lisp программа состоит из атомов.
</p>
<p class="text-indent">
	Существуют следующие атомы:
	<ul>
		<li>Точечная пара</li>
		<li>Символ</li>
		<li>Число</li>
		<li>Строка</li>
		<li>Флаг (Булево значение) (true | false)</li>
		<li>Функция</li>
		<li>Нативный объект (ссылается на любой объект C#)</li>
	</ul>
</p>

<p class="text-indent">
	<pre class="code-block">;	Точечная пара:
( symbolA . symbolB )

;	Цепочка пар является списком. Эти две записи эквивалентны:
( a . ( b . ( c . null )))
( a b c )</pre>
</p>
<p class="text-indent">
	Язык поддерживает два типа скобок: круглые и квадратные.
	Скобки равнозначны между собой, но нельзя сочетать разные скобки^
	<pre class="code-block">;   Корректно
( exp )
[ exp ]
;   Некорректно
( exp ]
[ exp )</pre>
</p>

<p class="text-indent">
	Интерпретатор исполняет программу в некотором контексте, который хранит значения символов. Контекст является таблицей, в которой символ является ключом, а значение - любой атом или список.
</p>
<p class="text-indent">
	Исполнение программы производится сходным с лисплм образом.
	<pre class="code-block">( procedureName argument1 argument2 ... )</pre>
</p>
<p class="text-indent">
	Сначала интерпретатор исполняет голову списка procedureName.<br>
	Если в результате исполнения получилась НЕ функция - исполнение прервётся с ошибкой.<br>
	Исполнимые функции делятся по двум параметрам:
	<ul>
		<li>вычисляются ли их аргументы перед вызовом</li>
		<li>вычисляются ли возвращаемое значение</li>
	</ul>
</p>
<p class="text-indent">
	Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
	Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
	Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
	Полученый результат является результатом вычисления выражения.
</p>
<p class="text-indent">
	Атомы, не являющиеся списками (парами) вычисляются следующим образом:
	<ul>
		<li>Числовые, Строковые и Булевы атомы остаются без изменений</li>
		<li>Атомы с нативными объектами остаются без изменений</li>
		<li>Атомы с функциями остаются без изменений</li>
		<li>Символы интерпретируются как ключи, по которым производится поиск в текущем и родительском контексте. Если значения найти не удалось - исполнение прерывается.</li>
	</ul>
</p>
<p class="text-indent">
	У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
	У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
	Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
	Это сделано для простоты интерпретатора.
</p>
<p class="text-indent">
	Функция объявляется выражением:
	<pre class="code-block">(lambda (arguments) body )</pre>
</p>
<p class="text-indent">
	Макрос:
	<pre class="code-block">(macros (arguments) body )</pre>
</p>
<p class="text-indent">
	Кроме того есть форма с явным определением флагов исполнения:
	<pre class="code-block">(syntax (arg res) (arguments) body )</pre>
	Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
	А res - флаг указывающий исполнять ли результат функции.
	Таким образом следующие выражения эквивалентны:
	<pre class="code-block">(lambda (arguments) body ) <--> (syntax (true false) (arguments) body )

(macros (arguments) body ) <--> (syntax (false true) (arguments) body )</pre>
</p>





	</div>
</div>




		</div>
		
	</section>
	
	<script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
	<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
	
</body>
</html>