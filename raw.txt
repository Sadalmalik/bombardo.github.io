
Добро пожаловать!

Bombardo - это мой домашний проект, выросший из различных экспериментов и разросшийся до такого размера, что я посчитал возможным выложить его в всеобщий доступ. Поскольку мой собственный диалект получился в результате экспериментов, я делал его под себя, поэтому он не соответствует каким-либо стандартам и соглашениям.

Надеюсь вам будет интересно и полезно с ним познакомится!







Я так же хотел накидать для этого сайта генератор статических страниц на своём же языке, но что-то залип и решил бросить дабы не терять больше времени. Задача вроде не сложная, но вот залип :(







Немного истории.
Началось всё лет 6 назад, когда я (как и многие программисты) увлёкся идеей создания своего Искусственного Интеллекта.
Я начал с того что стал подробно вникать в основные концепции начиная с представления знаний: фреймы, семантические сети, языки и нотации. Штурмовал википедию и все ресурсы которые находил. Ознакомился и с нейросетями. Но на тот момент они меня не зацепили.
Я выбрал в качестве основы сети семантические сети и стал экспериментировать. В начале просто создавать граф каких-то знаний. Узел представлял собой описание и список связей со многими другими узлами. При этом одновременно он являлся сам связью. Мне казалось это даст огромную гибкость. Но в итоге я начал путаться в том что творил. После нескольких итераций я оставил в узле три связи - источник, приёмник и тип связи. На этой основе я даже накидал некоторую вроде как базу знаний, которой можно было сообщать факты и которая сама задавала вопросы. Вопросы создавались рандомно и были довольно сумасшедшими: "Является ли Красный Ветром?".
В итоге после ещё нескольких итераций начав прикручивать логику исполнения (дабы алгоритмы тоже можно было записывать внутри сети) я окончательно осознал, что у меня получается кривая и монструозная интерпретация куска лиспа. Поэтому я всё это бросил и сел изучать лисп.
Какой лучший способ изучить язык? Написать свой интерпретатор языка! Что я и стал делать.






 
Язык Bombardo.

Как и в обычном Lisp программа состоит из атомов.
Существуют следующие атомы:
 - Точечная пара
 - Символ
 - Число
 - Строка
 - Флаг (Булево значение) (true | false)
 - Функция
 - Нативный объект (ссылается на любой объект C#)

Точечная пара:
<pre><code>
( symbolA . symbolB )
</code></pre>
Цепочка пар является списком. Эти две записи эквивалентны:
<pre><code>
( a . ( b . ( c . null )))
( a b c )
</code></pre>

Язык поддерживает два типа скобок: круглые и квадратные.
Скобки полностью равнозначны между собой, но нельзя сочетать разные скобки.
Корректно:
<pre><code>
( exp )
[ exp ]
</code></pre>
Некорректно:
<pre><code>
( exp ]
[ exp )
</code></pre>

Интерпретатор исполняет программу в некотором контексте, который хранит значения символов.
Контекст является таблицей, в которой символ является ключом, а значение - любой атом или список.

Исполнение программы производится сходным с лисплм образом.
<pre><code>
( procedureName argument1 argument2 ... )
</code></pre>
Сначала интерпретатор исполняет голову списка procedureName.
Если в результате исполнения получилась НЕ функция - исполнение прервётся с ошибкой.
Исполнимые функции делятся по двум параметрам:
 - вычисляются ли их аргументы перед вызовом
 - вычисляются ли возвращаемое значение
Если для функции требуется исполнения аргументов - интерпретатор исполняет каждый аргумент отдельно и составляет список из результатов.
Если нет - в качестве аргументов функции передаётся неизменённый список ( argument1 argument2 ... )
Если требуется - происходит вычисление результата функции в текущем контексте (таким образом реализованы макросы, см. ниже)
Полученый результат является результатом вычисления выражения.

Атомы, не являющиеся списками (парами) вычисляются следующим образом:
 - Числовые, Строковые и Булевы атомы остаются без изменений
 - Атомы с нативными объектами остаются без изменений
 - Атомы с функциями остаются без изменений
 - Символы интерпретируются как ключи, по которым производится поиск в текущем и родительском контексте. Если значения найти не удалось - исполнение прерывается.

У обычных функций (встроенных или определённых программистом через lambda) аргументы вычисляются перед вызовом самой функции, а результат возвращается как есть.
У макросов аргументы передаются как есть, а результат исполнения макроса подлежит вычислению.
Макросы в Bombardo вычисляются во время общего исполнения программы, а не заранее.
Это сделано для простоты интерпретатора.

Функция объявляется выражением:
<pre><code>
(lambda (arguments) body )
</code></pre>

Макрос:
<pre><code>
(macros (arguments) body )
</code></pre>

Кроме того есть форма с явным определением флагов исполнения:
<pre><code>
(syntax (arg res) (arguments) body )
</code></pre>
Где arg - флаг указывающий нужно ли исполнять аргументы перед вызовом
А res - флаг указывающий исполнять ли результат функции.
Таким образом следующие выражения эквивалентны:
<pre><code>
(lambda (arguments) body ) <--> (syntax (true false) (arguments) body )

(macros (arguments) body ) <--> (syntax (false true) (arguments) body )
</code></pre>











